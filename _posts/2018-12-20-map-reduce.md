---
layout: post
title: Map Reduce的一些笔记
category: tech
---

看了58同城的架构师孙剑的关于map-reduce的小文，写的很好，喜欢这种简短又能把核心点说清的文章，把核心点摘出来，以备自己快速回忆：

- <https://mp.weixin.qq.com/s/O-9msY6FpCseo7PgMPYEqg>
- <https://mp.weixin.qq.com/s/D6dc3nX_3bQc0kFiH-7shA>

两篇小文很赞，一定耐心读一遍。

#### 一览图

![](/images/20190213/1550063275752.png){:class="myimg"}

- 首先是mapper把一个文件从这台机器上load起来，mapper中就会产生这个MR中最核心的“key”，比如按照字符统计的例子里，那些字符就是核心的key
- mapper那台机器上，可能会运行个“合并函数”，用于把a的结果合并一下，没啥，就是为了提高效率
- 然后才是最重要的“分区函数”，这个分区函数运行在哪里？作者没提，我觉得应该还是在mapper的那台机器上，为什呢这么推测呢？因为，MR本质是要计算跟着数据走，能不传就不传输，那么，在没给这个计算结果找到对应的reducer之前，不能盲目的就把数据发出去，对吧？否则，发给谁，发往哪里，这个依据都没有。
- 那么就是“分区函数”，用户自己个儿写的，按照某种规则，原则啥的不说了，孙剑说的很清楚了，你不写也没事，MR会替你实现一个hash版本的
- 然后我认为，才开始传输数据，这个协调传输给那台reducer
- 一个key只会被一个reducer处理，这是一个细节，不同的reducer不可能处理同一个key
- MR系统幂等性概念很重要，不管哪个负责map的worker执行的结果，一定是不变的，产出的R个本地输出文件内容也一定是不变的
几个点还需要强调：
- 会开始在资源池中就初始化一堆的mapper和reducer，应该是有策略的，比如那些机器跑起来mapper，一台机器上跑几个mappers，reducer亦然
- 这尼玛就是一个资源池，既然是个资源池，就需要有人调度他们，那调度这事，肯定是MR系统实现的了，比如mapper应该总是问他“哥们，我这里有很多key和对应聚合出来的结果，我该发给谁啊？”，那么调度者就会跳出来，“哦！你这个这个发给这台机器的reducer，那个那个发给那台机器的reducer”。

![](/images/20190213/1550063555521.png){:class="myimg"}

- 这图，我理解，就是发生在一台机器上的
- 开始在这个node上load起来文件，分给worker去mapper
- mapper把中间结果存到磁盘上（落盘）
- reducer再把结果合并到输出文件，等着master去进一步调度
- 这之后，肯定还会有跨机器的reducer，但是这张图，仅仅是为了讲清楚一台机器上发生的事情

我的理解，不对的话，请留言指出。

#### 摘录

摘录一下他的一些精华字眼，您自己个儿去体会，我为何要摘录这些：

```
不妨假设，用户设置了M个map节点，R个reduce节点；例如：M=500，R=200
(1) 在集群中创建大量可执行实例副本(fork)；
(2) 这些副本中有一个master，其他均为worker，任务的分配由master完成， M个map实例和R个reduce实例由worker完成；
(3) 将输入数据分成M份，然后被分配到map任务的worker，从其中一份读取输入数据，执行用户的map函数处理，并在本地内存生成临时数据；
(4) 本地内存临时数据，通过分区函数，被分成R份，周期性的写到本地磁盘，由master调度，传给被分配到reduce任务的worker；
(5) 负责reduce任务的worker，从远程读取多个map输出的数据，执行用户的reduce函数处理，处理结果写入输出文件；
```

疑问：3中说的数据，如果启动mapper worker不在数据所在的机器上怎么办？难道需要传输？我理解，应该是就这数据来生成mapper的实例更高效。不过，细想一下，也不尽然，毕竟开始任务之前，你不知道你的任务会涉及到哪些数据，看来，mapper阶段是不可避免是要传输数据的把？疑惑？

这事，我再开个脑洞，就是不传数据，而是把任务传过去，吧mapper程序传过去，传到数据所在的节点上，让此节点上的workder承接这个mapper。这里，肯定是可以通过HDFS，全局查到数据在哪里的，在哪个node上，哪个block里，然后，给这些节点把程序发过去不就得了。不知道，人家是不是这么实现的。

我前面理解中说过的“调度”，这里得到验证，就是他说的`副本中有一个master`,他就是任务调度节点嘛。


```
(1) master：单点master会存储一些元数据，监控所有map与reduce的状态，记录哪个数据要给哪个map，哪个数据要给哪个reduce，掌控全局视野，做中控；
画外音：是不是和GFS的master非常像？
(2) worker：多个worker进行业务逻辑处理，具体一个worker是用来执行map还是reduce，是由master调度的；
画外音：是不是和工作线程池非常像？这里的worker是分布在多台机器上的而已。
```

worker就是个干活的，他既可以看mapper的事儿，也可以干reducer的事儿。


